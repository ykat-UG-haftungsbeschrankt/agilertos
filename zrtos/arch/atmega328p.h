/*
 * Copyright (c) 2024 ykat UG (haftungsbeschraenkt) - All Rights Reserved
 *
 * Permission for non-commercial use is hereby granted,
 * free of charge, without warranty of any kind.
 */
#ifndef ZRTOS_ARCH_ATMEGA328P_H_
#define ZRTOS_ARCH_ATMEGA328P_H_
#ifdef __cplusplus
extern "C" {
#endif


#if defined(ZRTOS_ARCH__ATMEGA328P) || defined(__DOXYGEN__)
#define ZRTOS_ARCH__FOUND

#include <util/delay_basic.h>

typedef uint8_t zrtos_arch_stack_t;
typedef int8_t zrtos_arch_stack_signed_t;
typedef uint8_t zrtos_arch_gpio_pin_t;
typedef uint16_t zrtos_arch_gpio_value_analog_t;

#define ZRTOS_ARCH__CPU_CLOCK_HZ    ( ( uint32_t ) F_CPU )          // thiz F_CPU variable set by the environment


#define ZRTOS_ARCH__BYTE_ALIGNMENT 1

#define ZRTOS_ARCH__FATAL() ((void(*)(void))0)();

#define ZRTOS_ARCH__SET_STACK_PTR(ptr) \
    (SP = (uint16_t)(ptr))

#define ZRTOS_ARCH__GET_STACK_PTR() \
    ((void*)SP)

#define ZRTOS_ARCH__IS_INTERRUPTS_DISABLED() \
    ((SREG & 0x80) == 0)

#define ZRTOS_ARCH__IS_INTERRUPTS_ENABLED() \
    ((SREG & 0x80) > 0)

#define ZRTOS_ARCH__DISABLE_INTERRUPTS() \
    asm volatile ( "cli" :: );

#define ZRTOS_ARCH__ENABLE_INTERRUPTS() \
    asm volatile ( "sei" :: );


zrtos_arch_stack_t * zrtos_arch__cpu_state_init_helper( zrtos_arch_stack_t * pxTopOfStack,
                                     zrtos_arch_callback_t pxCode,
                                     void * pvParameters )
{
uint16_t usAddress;

    /* Simulate how the stack would look after a call to vPortYield() generated by
     * the compiler. */

    /* The start of the task code will be popped off the stack last, so place
     * it on first. */
    usAddress = ( uint16_t ) pxCode;
    *pxTopOfStack = ( zrtos_arch_stack_t ) ( usAddress & ( uint16_t ) 0x00ff );
    pxTopOfStack--;

    usAddress >>= 8;
    *pxTopOfStack = ( zrtos_arch_stack_t ) ( usAddress & ( uint16_t ) 0x00ff );
    pxTopOfStack--;

#if defined(__AVR_3_BYTE_PC__)

    /* The AVR ATmega2560/ATmega2561 have 256KBytes of program memory and a 17-bit
     * program counter. When a code address is stored on the stack, it takes 3 bytes
     * instead of 2 for the other ATmega* chips.
     *
     * Store 0 as the top byte since we force all task routines to the bottom 128K
     * of flash. We do this by using the .lowtext label in the linker script.
     *
     * In order to do this properly, we would need to get a full 3-byte pointer to
     * pxCode. That requires a change to GCC. Not likely to happen any time soon.
     */
    *pxTopOfStack = 0;
    pxTopOfStack--;
#endif

    /* Next simulate the stack as if after a call to portSAVE_CONTEXT().
     * portSAVE_CONTEXT places the flags on the stack immediately after r0
     * to ensure the interrupts get disabled as soon as possible, and so ensuring
     *  the stack use is minimal should a context switch interrupt occur. */
    *pxTopOfStack = ( zrtos_arch_stack_t ) 0x00; /* R0 */
    pxTopOfStack--;
    *pxTopOfStack = 0x80;//enable interrupts
    pxTopOfStack--;

#if defined(__AVR_3_BYTE_PC__)

    /* If we have an ATmega256x, we are also saving the EIND register.
     * We should default to 0.
     */
    *pxTopOfStack = ( zrtos_arch_stack_t ) 0x00;    /* EIND */
    pxTopOfStack--;
#endif

#if defined(__AVR_HAVE_RAMPZ__)

    /* We are saving the RAMPZ register.
     * We should default to 0.
     */
    *pxTopOfStack = ( zrtos_arch_stack_t ) 0x00;    /* RAMPZ */
    pxTopOfStack--;
#endif

    /* Now the remaining registers. The compiler expects R1 to be 0. */
    *pxTopOfStack = ( zrtos_arch_stack_t ) 0x00;    /* R1 */

    /* Leave R2 - R23 untouched */
    pxTopOfStack -= 23;

    /* Place the parameter on the stack in the expected location. */
    usAddress = ( uint16_t ) pvParameters;
    *pxTopOfStack = ( zrtos_arch_stack_t ) ( usAddress & ( uint16_t ) 0x00ff );
    pxTopOfStack--;

    usAddress >>= 8;
    *pxTopOfStack = ( zrtos_arch_stack_t ) ( usAddress & ( uint16_t ) 0x00ff );

    /* Leave register R26 - R31 untouched */
    pxTopOfStack -= 7;

    return pxTopOfStack;
}

zrtos_arch_stack_t *zrtos_arch__cpu_state_init_b(
	 zrtos_arch_stack_t     *thiz
	//,size_t                length
	,zrtos_arch_callback_t callback
	,void                  *args
){
/*
	ZRTOS_DEBUG__CODE(
		static uint8_t pattern = 0xF0;
		memset(thiz,(int)(pattern++),length);
	);
*/
	return zrtos_arch__cpu_state_init_helper(
		 thiz
		,callback
		,args
	);
}

zrtos_arch_stack_t *zrtos_arch__cpu_state_init_a(
	 zrtos_arch_stack_t     *thiz
	//,size_t                length
	,zrtos_arch_callback_t callback
	,void                  *args
){
	zrtos_arch_stack_t *pxTopOfStack = thiz;
	zrtos_arch_stack_t *pxTopOfStackTmp = pxTopOfStack;
	uint16_t usAddress = (uint16_t)callback;
	zrtos_arch_stack_signed_t usValue = 0;

	pxTopOfStack -= 3;

	for(;usValue < 32;){
		/*if(usValue == 0x0A
		|| usValue == 0x1A
		|| usValue == 0x2A){
			usValue+=6;
		}*/
		*pxTopOfStack-- = usValue++;
	}

	pxTopOfStackTmp[0] = usAddress & 0x00ff;
	pxTopOfStackTmp[-1] = (usAddress >> 8) & 0x00ff;
	pxTopOfStackTmp[-2] = 0;
	pxTopOfStackTmp[-3] = 0x80;//enable interrupts
	pxTopOfStackTmp[-4] = 0;
	usAddress = (uint16_t)args;
	pxTopOfStackTmp[-27] = usAddress & 0x00ff;
	pxTopOfStackTmp[-28] = (usAddress >> 8) & 0x00ff;

	return pxTopOfStack;
}

#if 1
# define zrtos_arch__cpu_state_init zrtos_arch__cpu_state_init_a
#else
# define zrtos_arch__cpu_state_init zrtos_arch__cpu_state_init_b
#endif

#define ZRTOS_ARCH__GET_CPU_STATE_BUFFER_LENGTH() 33
#define ZRTOS_ARCH__GET_FN_CALL_STACK_LENGTH() 20

#define ZRTOS_ARCH__SAVE_CPU_STATE()                            \
    ;__asm__ __volatile__(                                      \
        "push   __tmp_reg__                             \n\t"   \
        "in     __tmp_reg__, __SREG__                   \n\t"   \
        "cli                                            \n\t"   \
        "push   __tmp_reg__                             \n\t"   \
        "push   __zero_reg__                            \n\t"   \
        "clr    __zero_reg__                            \n\t"   \
        "push   r2                                      \n\t"   \
        "push   r3                                      \n\t"   \
        "push   r4                                      \n\t"   \
        "push   r5                                      \n\t"   \
        "push   r6                                      \n\t"   \
        "push   r7                                      \n\t"   \
        "push   r8                                      \n\t"   \
        "push   r9                                      \n\t"   \
        "push   r10                                     \n\t"   \
        "push   r11                                     \n\t"   \
        "push   r12                                     \n\t"   \
        "push   r13                                     \n\t"   \
        "push   r14                                     \n\t"   \
        "push   r15                                     \n\t"   \
        "push   r16                                     \n\t"   \
        "push   r17                                     \n\t"   \
        "push   r18                                     \n\t"   \
        "push   r19                                     \n\t"   \
        "push   r20                                     \n\t"   \
        "push   r21                                     \n\t"   \
        "push   r22                                     \n\t"   \
        "push   r23                                     \n\t"   \
        "push   r24                                     \n\t"   \
        "push   r25                                     \n\t"   \
        "push   r26                                     \n\t"   \
        "push   r27                                     \n\t"   \
        "push   r28                                     \n\t"   \
        "push   r29                                     \n\t"   \
        "push   r30                                     \n\t"   \
        "push   r31                                     \n\t"   \
    );

#define ZRTOS_ARCH__SAVE_CPU_STATE_EX(ptr)                      \
    ZRTOS_ARCH__SAVE_CPU_STATE();                               \
    ;__asm__ __volatile__(                                      \
        "in     __tmp_reg__, __SP_L__                   \n\t"   \
        "sts    %0, __tmp_reg__                         \n\t"   \
        "in     __tmp_reg__, __SP_H__                   \n\t"   \
        "sts    %0 + 1, __tmp_reg__                     \n\t"   \
        : "=m" (ptr)                                            \
    );

#define ZRTOS_ARCH__LOAD_CPU_STATE()                            \
    ;__asm__ __volatile__(                                      \
        "pop    r31                                     \n\t"   \
        "pop    r30                                     \n\t"   \
        "pop    r29                                     \n\t"   \
        "pop    r28                                     \n\t"   \
        "pop    r27                                     \n\t"   \
        "pop    r26                                     \n\t"   \
        "pop    r25                                     \n\t"   \
        "pop    r24                                     \n\t"   \
        "pop    r23                                     \n\t"   \
        "pop    r22                                     \n\t"   \
        "pop    r21                                     \n\t"   \
        "pop    r20                                     \n\t"   \
        "pop    r19                                     \n\t"   \
        "pop    r18                                     \n\t"   \
        "pop    r17                                     \n\t"   \
        "pop    r16                                     \n\t"   \
        "pop    r15                                     \n\t"   \
        "pop    r14                                     \n\t"   \
        "pop    r13                                     \n\t"   \
        "pop    r12                                     \n\t"   \
        "pop    r11                                     \n\t"   \
        "pop    r10                                     \n\t"   \
        "pop    r9                                      \n\t"   \
        "pop    r8                                      \n\t"   \
        "pop    r7                                      \n\t"   \
        "pop    r6                                      \n\t"   \
        "pop    r5                                      \n\t"   \
        "pop    r4                                      \n\t"   \
        "pop    r3                                      \n\t"   \
        "pop    r2                                      \n\t"   \
        "pop    __zero_reg__                            \n\t"   \
        "pop    __tmp_reg__                             \n\t"   \
        "out    __SREG__, __tmp_reg__                   \n\t"   \
        "pop    __tmp_reg__                             \n\t"   \
    );

#define ZRTOS_ARCH__LOAD_CPU_STATE_EX(ptr)                      \
    ;__asm__ __volatile__(                                      \
        "lds    __tmp_reg__, %0                         \n\t"   \
        "out    __SP_L__, __tmp_reg__                   \n\t"   \
        "lds    __tmp_reg__, %0 + 1                     \n\t"   \
        "out    __SP_H__, __tmp_reg__                   \n\t"   \
        : : "m" (ptr)                                           \
    );                                                          \
	ZRTOS_ARCH__LOAD_CPU_STATE();

#define ZRTOS_ARCH__RETURN_FROM_INTERRUPT() \
    __asm__ __volatile__("reti");

#endif

void zrtos_arch__delay_microseconds(uint16_t us){
	_delay_loop_2((ZRTOS_ARCH__CPU_CLOCK_HZ/4000000) * us);
}

void zrtos_arch__delay_milliseconds(uint16_t ms){
	while(ms--){
		zrtos_arch__delay_microseconds(1000);
	}
}

#ifdef __cplusplus
}
#endif
#endif