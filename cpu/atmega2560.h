/* vim: noai:ts=4
 * Copyright (c) 2024 ykat UG (haftungsbeschraenkt) - All Rights Reserved
 *
 * Permission for non-commercial use is hereby granted,
 * free of charge, without warranty of any kind.
 */
#ifndef ZRTOS_CPU_ATMEGA2560_H_
#define ZRTOS_CPU_ATMEGA2560_H_
#ifdef __cplusplus
extern "C" {
#endif


#ifdef ZRTOS_CPU__ATMEGA2560

#include <avr/interrupt.h>
#include <avr/wdt.h>

#define ZRTOS__BYTE_ALIGNMENT 1

#define ZRTOS__FATAL() ((void(*)(void))0)();

/* Critical section management. */
#define ZRTOS__CRITICAL_ENTER() \
asm volatile ( "in		__tmp_reg__, __SREG__" :: );	\
asm volatile ( "cli" :: );								\
asm volatile ( "push	__tmp_reg__" :: )

#define ZRTOS__CRITICAL_EXIT()\
asm volatile ( "pop		__tmp_reg__" :: );				\
asm volatile ( "out		__SREG__, __tmp_reg__" :: )

#define ZRTOS__INTERRUPTS_IS_DISABLED()                 \
	((SREG & 0x80) == 0)

#define ZRTOS__INTERRUPTS_IS_ENABLED()                 \
	((SREG & 0x80) > 0)

#define ZRTOS__INTERRUPTS_DISABLE()  \
asm volatile ( "cli" :: );

#define ZRTOS__INTERRUPTS_ENABLE()   \

asm volatile ( "sei" :: );

#define ZRTOS__WATCH_DOG_START() \
	wdt_enable(WDTO_8S);

#define ZRTOS__WATCH_DOG_STOP() \
	wdt_disable();

#define ZRTOS__WATCH_DOG_RESET() \
	wdt_reset();

size_t zrtos__get_free_ram(){
	extern int __heap_start;
	return zrtos_types__ptr_get_byte_distance((void*)SP,(void*)&__heap_start);
}

zrtos_task_heap_t * pxPortInitialiseStack( zrtos_task_heap_t * pxTopOfStack,
                                     zrtos_task_callback_t pxCode,
                                     void * pvParameters )
{
uint16_t usAddress;

    /* Simulate how the stack would look after a call to vPortYield() generated by
     * the compiler. */

    /* The start of the task code will be popped off the stack last, so place
     * it on first. */
    usAddress = ( uint16_t ) pxCode;
    *pxTopOfStack = ( zrtos_task_heap_t ) ( usAddress & ( uint16_t ) 0x00ff );
    pxTopOfStack--;

    usAddress >>= 8;
    *pxTopOfStack = ( zrtos_task_heap_t ) ( usAddress & ( uint16_t ) 0x00ff );
    pxTopOfStack--;

#if defined(__AVR_3_BYTE_PC__)

    /* The AVR ATmega2560/ATmega2561 have 256KBytes of program memory and a 17-bit
     * program counter. When a code address is stored on the stack, it takes 3 bytes
     * instead of 2 for the other ATmega* chips.
     *
     * Store 0 as the top byte since we force all task routines to the bottom 128K
     * of flash. We do this by using the .lowtext label in the linker script.
     *
     * In order to do this properly, we would need to get a full 3-byte pointer to
     * pxCode. That requires a change to GCC. Not likely to happen any time soon.
     */
    *pxTopOfStack = 0;
    pxTopOfStack--;
#endif

    /* Next simulate the stack as if after a call to portSAVE_CONTEXT().
     * portSAVE_CONTEXT places the flags on the stack immediately after r0
     * to ensure the interrupts get disabled as soon as possible, and so ensuring
     *  the stack use is minimal should a context switch interrupt occur. */
    *pxTopOfStack = ( zrtos_task_heap_t ) 0x00; /* R0 */
    pxTopOfStack--;
    *pxTopOfStack = 0x80;//enable interrupts
    pxTopOfStack--;

#if defined(__AVR_3_BYTE_PC__)

    /* If we have an ATmega256x, we are also saving the EIND register.
     * We should default to 0.
     */
    *pxTopOfStack = ( zrtos_task_heap_t ) 0x00;    /* EIND */
    pxTopOfStack--;
#endif

#if defined(__AVR_HAVE_RAMPZ__)

    /* We are saving the RAMPZ register.
     * We should default to 0.
     */
    *pxTopOfStack = ( zrtos_task_heap_t ) 0x00;    /* RAMPZ */
    pxTopOfStack--;
#endif

    /* Now the remaining registers. The compiler expects R1 to be 0. */
    *pxTopOfStack = ( zrtos_task_heap_t ) 0x00;    /* R1 */

    /* Leave R2 - R23 untouched */
    pxTopOfStack -= 23;

    /* Place the parameter on the stack in the expected location. */
    usAddress = ( uint16_t ) pvParameters;
    *pxTopOfStack = ( zrtos_task_heap_t ) ( usAddress & ( uint16_t ) 0x00ff );
    pxTopOfStack--;

    usAddress >>= 8;
    *pxTopOfStack = ( zrtos_task_heap_t ) ( usAddress & ( uint16_t ) 0x00ff );

    /* Leave register R26 - R31 untouched */
    pxTopOfStack -= 7;

    return pxTopOfStack;
}

zrtos_task_heap_t *zrtos_task_heap__init(
	 zrtos_task_heap_t     *thiz
	,size_t                length
	,zrtos_task_callback_t callback
	,void                  *args
){
	ZRTOS__DEBUG_CODE(
		static uint8_t pattern = 0xF0;
		memset(thiz,(int)(pattern++),length);
	);
	return pxPortInitialiseStack(
		 zrtos_types__ptr_add(thiz,length)-1
        ,callback
        ,args
	);
}

#if 0
zrtos_task_heap_t *zrtos_task_heap__init(
	 zrtos_task_heap_t     *thiz
	,size_t                length
	,zrtos_task_callback_t callback
	,void                  *args
){
	zrtos_task_heap_t *pxTopOfStack = zrtos_types__ptr_add(thiz,length);
	zrtos_task_heap_t *pxTopOfStackTmp = pxTopOfStack;
	uint16_t usAddress = (uint16_t)callback;
	zrtos_task_heap_signed_t usValue = -6;

	for(;usValue < 0x32;){
		if(usValue == 0x0A
		|| usValue == 0x1A
		|| usValue == 0x2A){
			usValue+=6;
		}
		*pxTopOfStack-- = usValue++;
	}

	pxTopOfStackTmp[-3] = usAddress & 0x00ff;
	pxTopOfStackTmp[-4] = (usAddress >> 8) & 0x00ff;
	pxTopOfStackTmp[-5] = 0;
	pxTopOfStackTmp[-6] = 0x80;//enable interrupts
	pxTopOfStackTmp[-7] = 0;
	usAddress = (uint16_t)args;
	pxTopOfStackTmp[-30] = usAddress & 0x00ff;
	pxTopOfStackTmp[-31] = (usAddress >> 8) & 0x00ff;

	return ++pxTopOfStack;
}
#endif

#define _ZRTOS_TASK__SAVE(ptr)                                  \
	;__asm__ __volatile__(                                      \
		"push   __tmp_reg__                             \n\t"   \
		"in     __tmp_reg__, __SREG__                   \n\t"   \
		"cli                                            \n\t"   \
		"push   __tmp_reg__                             \n\t"   \
		"push   __zero_reg__                            \n\t"   \
		"clr    __zero_reg__                            \n\t"   \
		"push   r2                                      \n\t"   \
		"push   r3                                      \n\t"   \
		"push   r4                                      \n\t"   \
		"push   r5                                      \n\t"   \
		"push   r6                                      \n\t"   \
		"push   r7                                      \n\t"   \
		"push   r8                                      \n\t"   \
		"push   r9                                      \n\t"   \
		"push   r10                                     \n\t"   \
		"push   r11                                     \n\t"   \
		"push   r12                                     \n\t"   \
		"push   r13                                     \n\t"   \
		"push   r14                                     \n\t"   \
		"push   r15                                     \n\t"   \
		"push   r16                                     \n\t"   \
		"push   r17                                     \n\t"   \
		"push   r18                                     \n\t"   \
		"push   r19                                     \n\t"   \
		"push   r20                                     \n\t"   \
		"push   r21                                     \n\t"   \
		"push   r22                                     \n\t"   \
		"push   r23                                     \n\t"   \
		"push   r24                                     \n\t"   \
		"push   r25                                     \n\t"   \
		"push   r26                                     \n\t"   \
		"push   r27                                     \n\t"   \
		"push   r28                                     \n\t"   \
		"push   r29                                     \n\t"   \
		"push   r30                                     \n\t"   \
		"push   r31                                     \n\t"   \
		"in     __tmp_reg__, __SP_L__                   \n\t"   \
		"sts    %0, __tmp_reg__                         \n\t"   \
		"in     __tmp_reg__, __SP_H__                   \n\t"   \
		"sts    %0 + 1, __tmp_reg__                     \n\t"   \
		: "=m" (ptr)                                            \
	);

#define _ZRTOS_TASK__RESTORE(ptr)                               \
	;__asm__ __volatile__(                                      \
		"lds    __tmp_reg__, %0                         \n\t"   \
		"out    __SP_L__, __tmp_reg__                   \n\t"   \
		"lds    __tmp_reg__, %0 + 1                     \n\t"   \
		"out    __SP_H__, __tmp_reg__                   \n\t"   \
		"pop    r31                                     \n\t"   \
		"pop    r30                                     \n\t"   \
		"pop    r29                                     \n\t"   \
		"pop    r28                                     \n\t"   \
		"pop    r27                                     \n\t"   \
		"pop    r26                                     \n\t"   \
		"pop    r25                                     \n\t"   \
		"pop    r24                                     \n\t"   \
		"pop    r23                                     \n\t"   \
		"pop    r22                                     \n\t"   \
		"pop    r21                                     \n\t"   \
		"pop    r20                                     \n\t"   \
		"pop    r19                                     \n\t"   \
		"pop    r18                                     \n\t"   \
		"pop    r17                                     \n\t"   \
		"pop    r16                                     \n\t"   \
		"pop    r15                                     \n\t"   \
		"pop    r14                                     \n\t"   \
		"pop    r13                                     \n\t"   \
		"pop    r12                                     \n\t"   \
		"pop    r11                                     \n\t"   \
		"pop    r10                                     \n\t"   \
		"pop    r9                                      \n\t"   \
		"pop    r8                                      \n\t"   \
		"pop    r7                                      \n\t"   \
		"pop    r6                                      \n\t"   \
		"pop    r5                                      \n\t"   \
		"pop    r4                                      \n\t"   \
		"pop    r3                                      \n\t"   \
		"pop    r2                                      \n\t"   \
		"pop    __zero_reg__                            \n\t"   \
		"pop    __tmp_reg__                             \n\t"   \
		"out    __SREG__, __tmp_reg__                   \n\t"   \
		"pop    __tmp_reg__                             \n\t"   \
		: : "m" (ptr)                                           \
	);

void _zrtos_task_scheduler__isr_start(void){
	ZRTOS__INTERRUPTS_DISABLE();
	// Clear registers
	TCCR1A = 0;
	TCCR1B = 0;
	TCNT1 = 0;

	// 1000 Hz (16000000/((249+1)*64))
	OCR1A = 249;
	// CTC
	TCCR1B |= (1 << WGM12);
	// Prescaler 64
	TCCR1B |= (1 << CS11) | (1 << CS10);
	// Output Compare Match A Interrupt Enable
	TIMSK1 |= (1 << OCIE1A);
	ZRTOS__INTERRUPTS_ENABLE();
}

void _zrtos_task_scheduler__isr_stop(void){
	ZRTOS__INTERRUPTS_DISABLE();
	TIMSK1 &= ~(1 << OCIE1A);
	ZRTOS__INTERRUPTS_ENABLE();
}

#define ZRTOS_TASK_SCHEDULER__ISR_RETURN() \
	__asm__ __volatile__("reti");

void _zrtos_task_scheduler__isr_reset_counter(void){
	TCNT1  = 0;
}

__attribute__((naked))ISR(TIMER1_COMPA_vect){
	_zrtos_task_scheduler__on_tick();
}

ISR(WDT_vect){
	ZRTOS__FATAL();
}

#endif


#ifdef __cplusplus
}
#endif
#endif